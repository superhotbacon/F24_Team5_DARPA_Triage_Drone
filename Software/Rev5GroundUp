#define _USE_MATH_DEFINES
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include "ifxAvian/Avian.h"
#include "ifxAlgo/FFT.h"
#include "ifxAlgo/Algo.h"
#include "ifxFmcw/DeviceFmcw.h"
#include "ifxFmcw/MetricsFmcw.h"
#include "ifxFmcw/DeviceFmcwTypes.h"
#include "ifxBase/Error.h"
#include "ifxBase/Version.h"
#include <unistd.h>
#include "ifxBase/Complex.h"



// Define M_PI manually if it is still not recognized
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif
//////////////////////////Old
#define FFT_SIZE_RANGE_PROFILE //
#define PHASE_BUFFER_SIZE 256 //MUST BE POWER OF 2
#define LOW_BREATHING 0.15
#define HIGH_BREATHING 0.6
#define LOW_HEART 0.85
#define HIGH_HEART 2.4
#define FILTER_ORDER 21

/////////////////////////////////////New
#define RANGE_RESOLUTION 0.0005
#define MAX_RANGE_M 1.0
#define MAX_SPEED_M_S 1.0
#define SPEED_RESOLUTION_M_S 0.001
#define CENTER_FREQUENCY 0.0 //0 sets middle of bandwitdth of radar
#define C 299792458.0
#define OVERFLOW_BUF_SIZE 256
#define NUM_RX_ANTENNAS 1



ifx_Float_t breathing_b[FILTER_ORDER] = {
    0.007313837127168415, 
    0.009386036920457386, 
    0.01538868930614381, 
    0.02474755515295232, 
    0.036554722423133006, 
    0.04965777770448871, 
    0.06277345990028897, 
    0.07461451916940258, 
    0.08401716469240755, 
    0.09005640738673612, 
    0.09213779788313568, 
    0.09005640738673612, 
    0.08401716469240755, 
    0.07461451916940258, 
    0.06277345990028897, 
    0.04965777770448871, 
    0.036554722423133006, 
    0.02474755515295232, 
    0.01538868930614381, 
    0.009386036920457386, 
    0.007313837127168415,
};

ifx_Float_t heart_b[FILTER_ORDER] = {
    0.006640638910216269, 
    0.008758057930780494, 
    0.014708206397157428, 
    0.024152371131549114, 
    0.03631880147898397, 
    0.05008085188252181, 
    0.06408095781326595, 
    0.07688568069269515, 
    0.08715286038261551, 
    0.09379013987956314, 
    0.09608502796167993, 
    0.09379013987956314, 
    0.08715286038261551, 
    0.07688568069269515, 
    0.06408095781326595, 
    0.05008085188252181, 
    0.03631880147898397, 
    0.024152371131549114, 
    0.014708206397157428, 
    0.008758057930780494, 
    0.006640638910216269, 
};
static ifx_Float_t phase_buffer[PHASE_BUFFER_SIZE];
static int phase_index = 0;

int num_samples_per_chirp, num_chirps_per_frame, sample_rate_Hz, start_frequency_Hz, end_frequency_Hz, chirp_repetition_time, frame_repetition_time; 
float frame_rate, chirp_rate;

// Calculate range resolution and maximum range based on sensor configuration
double chirp_bandwidth;
double range_res;
double slope_chirp;
double max_range;

void unwrap_phase(ifx_Float_t* phase, int len);
void process_vital_signs(ifx_Float_t* phase_buf,ifx_FFT_t* PhaseFFt, int len, ifx_Filter_R_t* br_filt, ifx_Filter_R_t* hr_filt,ifx_Vector_R_t* filterOutputHr ,ifx_Vector_R_t* filterOutputBr );
//void calc_range_fft(ifx_FFT_t* phaseFFT, ifx_FFT_t* RangeFFT, ifx_Cube_R_t* frame, ifx_Complex_t* out);
void calc_range_fft(ifx_FFT_t* RangeFFT, ifx_Cube_R_t* frame, ifx_Vector_C_t** vectorRangeArray);
void process_frame(ifx_Cube_R_t* frame, double max_range, ifx_Vector_C_t** vectorRangeArray, ifx_Vector_C_t** vectorPhaseArray, ifx_FFT_t* PhaseFFT, ifx_FFT_t* RangeFFT, ifx_Filter_R_t* br_filt, ifx_Filter_R_t* hr_filt,
    ifx_Vector_R_t* filterOutputHr ,ifx_Vector_R_t* filterOutputBr );


int main() {

    // Create radar device instance
    ifx_Avian_Device_t* device = ifx_avian_create();
    if (device == NULL) {
        fprintf(stderr, "Failed to create radar device: %s\n", ifx_error_to_string(ifx_error_get()));
        return -1;
    }

    // Print SDK version and device information
    printf("Radar SDK Version: %s\n", ifx_sdk_get_version_string_full());
    printf("UUID of board: %s\n", ifx_avian_get_board_uuid(device));
    printf("Sensor: %u\n", ifx_avian_get_sensor_type(device));

    // Create radar device configuration
    ifx_Avian_Config_t device_config;
    ifx_avian_get_config_defaults(device, &device_config);
    if (ifx_error_get() != IFX_OK) {
        fprintf(stderr, "Failed to get radar defaults: %s\n", ifx_error_to_string(ifx_error_get()));
        ifx_avian_destroy(device);
        return -1;
    }
    ifx_Avian_Metrics_t Metrics;
    //set metrics
    Metrics.range_resolution_m = RANGE_RESOLUTION;
    Metrics.max_range_m = MAX_RANGE_M;
    Metrics.max_speed_m_s = MAX_SPEED_M_S;
    Metrics.speed_resolution_m_s = SPEED_RESOLUTION_M_S;
    //turn metrics into a config
    ifx_avian_metrics_to_config(device, &Metrics, true, &device_config); //"true" rounds to nearest power of 2
    if (ifx_error_get() != IFX_OK) {
        fprintf(stderr, "Failed to set metrics to config: %s\n", ifx_error_to_string(ifx_error_get()));
        ifx_avian_destroy(device);
        return -1;
    }
    // Apply the configuration to the radar device
    ifx_avian_set_config(device, &device_config);
    // Check for errors after setting the configuration
    if (ifx_error_get() != IFX_OK) {
        fprintf(stderr, "Failed to set device configuration: %s\n", ifx_error_to_string(ifx_error_get()));
        ifx_avian_destroy(device);
        return -1;
    }
    //put the paramters into some global variables
    sample_rate_Hz = device_config.sample_rate_Hz;
    start_frequency_Hz = device_config.start_frequency_Hz;
    end_frequency_Hz = device_config.end_frequency_Hz;
    num_samples_per_chirp = device_config.num_samples_per_chirp;
    num_chirps_per_frame = device_config.num_chirps_per_frame;
    chirp_repetition_time = device_config.chirp_repetition_time_s;
    frame_repetition_time = device_config.frame_repetition_time_s;
    frame_rate = 1.0/frame_repetition_time;
    chirp_rate = 1.0/chirp_repetition_time;


    // Calculate range resolution and maximum range based on sensor configuration
    chirp_bandwidth = device_config.end_frequency_Hz - device_config.start_frequency_Hz; //validated
    range_res = (C) / (2 * chirp_bandwidth);
    printf("Range resolution: %.3f m\n", range_res);
    slope_chirp = chirp_bandwidth / device_config.chirp_repetition_time_s;
    max_range = (device_config.sample_rate_Hz * C) / (2 * slope_chirp); //from radar sdk

/////////////////////Create FFT types
    ifx_FFT_t* RangeFFT= ifx_fft_create(IFX_FFT_TYPE_R2C, num_samples_per_chirp); //MUST BE power of 2
    ifx_FFT_t* PhaseFFT= ifx_fft_create(IFX_FFT_TYPE_R2C, PHASE_BUFFER_SIZE); //MUST BE POWER OF 2 FOR SIZE
    if (ifx_error_get() != IFX_OK) {
        fprintf(stderr, "Failed to make fft objects: %s\n", ifx_error_to_string(ifx_error_get()));
        ifx_avian_destroy(device);
        return -1;
    }
    printf("Maximum range: %.3f m\n", max_range);

    ifx_Cube_R_t* frame = ifx_cube_create_r(NUM_RX_ANTENNAS, num_chirps_per_frame, num_samples_per_chirp);
    if (frame == NULL) {
        fprintf(stderr, "Failed to create frame structure.\n");
        return -1;
    }

    //create vector types to store output of the range fft
    ifx_Vector_C_t** vectorRangeArray = malloc(num_chirps_per_frame * sizeof(ifx_Vector_C_t));
    for(int i = 0; i < num_chirps_per_frame; i++){
        vectorRangeArray[i] = ifx_vec_create_c(num_samples_per_chirp);
    }
    ifx_Vector_C_t* vectorPhaseArray[PHASE_BUFFER_SIZE];
    for(int i = 0; i < PHASE_BUFFER_SIZE; i++){
        vectorPhaseArray[i] = ifx_vec_create_c(PHASE_BUFFER_SIZE);
    }
    //create filter types to be passed

    ifx_Vector_R_t* brCoefs = ifx_vec_create_r(FILTER_ORDER);
    ifx_vec_rawview_r(brCoefs, breathing_b, FILTER_ORDER, 1);

    ifx_Vector_R_t* hrCoefs = ifx_vec_create_r(FILTER_ORDER);
    ifx_vec_rawview_r(hrCoefs, heart_b, FILTER_ORDER, 1);

    //since its an FIR filter, numerator coef is 1
    ifx_Vector_R_t* numeratorCoefs = ifx_vec_create_r(FILTER_ORDER);
    numeratorCoefs->data[FILTER_ORDER - 1] = 1.0;


    ifx_Filter_R_t* br_filt = ifx_signal_filt_create_r(numeratorCoefs, brCoefs);
    ifx_Filter_R_t* hr_filt = ifx_signal_filt_create_r(numeratorCoefs, hrCoefs);


    ifx_Vector_R_t* filterOutputBr = ifx_vec_create_r(PHASE_BUFFER_SIZE);
    ifx_Vector_R_t* filterOutputHr = ifx_vec_create_r(PHASE_BUFFER_SIZE);

    while (1) {
        // Acquire next frame from radar sensor
        frame = ifx_avian_get_next_frame(device, NULL);
        if (frame == NULL) {
            fprintf(stderr, "Failed to acquire frame: %s\n", ifx_error_to_string(ifx_error_get()));
            break; 
        }
        // Process the acquired frame data
        process_frame(frame, max_range, vectorRangeArray, vectorPhaseArray, PhaseFFT, RangeFFT, br_filt, hr_filt, filterOutputHr , filterOutputBr );
    }
    // Free the acquired frame after processing
    ifx_cube_destroy_r(frame);
    // Clean up and release radar resources
    ifx_avian_destroy(device);
    return 0;
}


void unwrap_phase(ifx_Float_t* phase, int len) {
    for (int i = 1; i < len; i++) {
        ifx_Float_t dp = phase[i] - phase[i-1];
        if (dp > M_PI) {
            for (int j = i; j < len; j++) {
                phase[j] -= 2 * M_PI;
            }
        } else if (dp < -M_PI) {
            for (int j = i; j < len; j++) {
                phase[j] += 2 * M_PI;
            }
        }
    }
}


void calc_range_fft(ifx_FFT_t* RangeFFT, ifx_Cube_R_t* frame, ifx_Vector_C_t** vectorRangeArray) {

    ///vectorRangeArray needs to be a pointer to an array of ifx_vector*s
    /*
        Global variable reference
        sample_rate_Hz = device_config.sample_rate_Hz;
        start_frequency_Hz = device_config.start_frequency_Hz;
        end_frequency_Hz = device_config.end_frequency_Hz;
        num_samples_per_chirp = device_config.num_samples_per_chirp;
        num_chirps_per_frame = device_config.num_chirps_per_frame;
        chirp_repetition_time = device_config.chirp_repetition_time;
        frame_repetition_time = device_config.frame_repetition_time;
        frame_rate = 1.0/frame_repetition_time;
        chirp_rate = 1.0/chirp_repetition_time;
    */
    int num_samples = num_samples_per_chirp; 
    int fft_len = num_samples_per_chirp;
    int out_len = fft_len / 2;      // Only first half (excluding DC symmetries)
    ifx_Matrix_R_t matrix;
    //matrix.dimensions = 2; try without this first
    ifx_Matrix_R_t* matrix_ptr = &matrix;

    // Initialize output buffer to zeros. Do we need this?
    /*for (int bin = 0; bin < out_len; bin++) {
        out[bin].data[0] = 0.0;
        out[bin].data[1] = 0.0;
    } */     
    
        //vector and matrix resolve to the same back end deftype. Dont know why infineon did it this way tbh. Kinda goofy ahh
        for (int chirp = 0; chirp < num_chirps_per_frame; chirp++) {
            // Get pointer to the data for this chirp. We assume frame->data[ant] 
            // is an array of pointers to sample arrays.
            //ifx_Float_t* chirp_data = frame->data[ant][chirp];
            //ifx_Float_t* chirp_data = frame->data + (chirp * num_samples + );
            //get current chirp
            ifx_cube_get_slice_r(frame, chirp, matrix_ptr);

            // Remove DC offset: compute average of the chirp samples.
            double sum = 0.0;
            int s;
            for (s = 0; s < num_samples; s++) {
                sum += IFX_MAT_AT(matrix_ptr, s, 0);//macro to get the element
            }
            double avg = sum / num_samples;

            //subtract dc offset
            for(s = 0; s < num_samples; s++){
                IFX_MAT_AT(matrix_ptr, s, 0) = IFX_MAT_AT(matrix_ptr, s, 0) - avg;
            }

            // Also apply Blackman–Harris window; compute window coefficients.
            // The Blackman–Harris window coefficients (for example) are:
            // w[n] = 0.35875 - 0.48829*cos(2*pi*n/(N-1)) + 0.14128*cos(4*pi*n/(N-1)) - 0.01168*cos(6*pi*n/(N-1))
            /*lets look into windowing
            for (s = 0; s < num_samples; s++) {
                double window = 0.35875
                                - 0.48829 * cos((2 * M_PI * s) / (num_samples - 1))
                                + 0.14128 * cos((4 * M_PI * s) / (num_samples - 1))
                                - 0.01168 * cos((6 * M_PI * s) / (num_samples - 1));
                signal[s] = (chirp_data[s] - avg) * window;
            }
            // Zero-pad the rest of the signal buffer.
            for (s = num_samples; s < fft_len; s++) {
                signal[s] = 0.0;
            }
                */
            // Compute FFT for this chirp.
            //WARNING: this should work with the matrix type. If not try putting in the vect?
            ifx_fft_run_rc(RangeFFT, &matrix, vectorRangeArray[chirp]);
            // Scale the FFT output: divide by num_samples and multiply results by 2.
            // (Note: In the Python code, FFT result is divided by num_samples and multiplied by 2.)
            for (int bin = 0; bin < out_len; bin++) {
                vectorRangeArray[chirp][bin].data->data[0]= vectorRangeArray[chirp][bin].data->data[0] / (num_samples * 2.0);
                vectorRangeArray[chirp][bin].data->data[1] = vectorRangeArray[chirp][bin].data->data[1] / (num_samples * 2.0);
            }
        } // End of chirp loop
    
}


void process_vital_signs(ifx_Float_t* phase_buf, ifx_FFT_t* PhaseFFT, int len, ifx_Filter_R_t* br_filt, ifx_Filter_R_t* hr_filt,ifx_Vector_R_t* filterOutputHr ,ifx_Vector_R_t* filterOutputBr) {
    int i;
    static int processNum = 0;
    ifx_Float_t unwrapped_phase[PHASE_BUFFER_SIZE];
    for (i = 0; i < len; i++) {
        unwrapped_phase[i] = phase_buf[i];
    }
    unwrap_phase(unwrapped_phase, len);
    
    for(i = 0; i < len; i++){
    printf("Phase: %f, ", (float)phase_buf[i]);
    }    


    
    ifx_Float_t filtered_breathing[PHASE_BUFFER_SIZE] = {0};
    ifx_Float_t filtered_heart[PHASE_BUFFER_SIZE] = {0};
    //fir_filter(breathing_b, FILTER_ORDER, unwrapped_phase, len, filtered_breathing); REPLACE WITH INFINEON FIR FUNCTIONS
    //fir_filter(heart_b, FILTER_ORDER, unwrapped_phase, len, filtered_heart);
    //loadvalues of phase buf into output vector, then filter the output vector based on the fir filters defined in main
    ifx_vec_rawview_r(filterOutputHr, phase_buf, PHASE_BUFFER_SIZE, 1);
    ifx_vec_rawview_r(filterOutputBr, phase_buf, PHASE_BUFFER_SIZE, 1);

    //ifx_signal_filt_run_r(br_filt, filterOutputBr, filterOutputBr);
    //ifx_signal_filt_run_r(hr_filt,filterOutputHr, filterOutputHr);

    //ifx_Float_t* bp_in = (ifx_Float_t*)calloc(FFT_SIZE_VITAL, sizeof(ifx_Float_t));
    //ifx_Float_t* heart_in = (ifx_Float_t*)calloc(FFT_SIZE_VITAL, sizeof(ifx_Float_t));
    /*
    for (i = 0; i < len; i++) {
        bp_in[i] = filtered_breathing[i];
        heart_in[i] = filtered_heart[i];
    }
    */
    //left off here
    //ifx_fft_run_rc(PhaseFFT, filterOutputBr, filtered_breathing);
    //ifx_fft_run_rc(PhaseFFT, filterOutputHr, filtered_heart);
    /////////////
    int bp_peak_index = 0, heart_peak_index = 0;
    ifx_Float_t bp_max = 0.0, heart_max = 0.0;
    int fft_bins = PHASE_BUFFER_SIZE/2 + 1;
   //////// printf("HERE FISHY FISHY (SEG FAULT FINDER V)\n");
   /*
    for (i = 0; i < fft_bins; i++) {
        ifx_Float_t mag_bp = sqrt(IFX_COMPLEX_REAL(filtered_breathing[i]) * IFX_COMPLEX_REAL(filtered_breathing[i]) +
                             IFX_COMPLEX_IMAG(filtered_breathing[i]) * IFX_COMPLEX_IMAG(filtered_breathing[i]));
        ifx_Float_t mag_hr = sqrt(IFX_COMPLEX_REAL(filtered_breathing[i]) * IFX_COMPLEX_REAL(filtered_breathing[i]) +
                             IFX_COMPLEX_IMAG(filtered_breathing[i]) * IFX_COMPLEX_IMAG(filtered_breathing[i]));
        if (mag_bp > bp_max) {
            bp_max = mag_bp;
            bp_peak_index = i;
        }
        if (mag_hr > heart_max) {
            heart_max = mag_hr;
            heart_peak_index = i;
        }
    }
    */
    /*
    double freq_resolution = VITAL_SIG_SAMPLE_RATE / (double)FFT_SIZE_VITAL;
    double breathing_rate_hz = bp_peak_index * freq_resolution;
    double heart_rate_hz = heart_peak_index * freq_resolution;
    double breathing_rate_bpm = breathing_rate_hz * 60.0;
    double heart_rate_bpm = heart_rate_hz * 60.0;
    printf("PROCESS VITALS ITERATION: %d ", processNum);
    printf("Estimated Breathing Rate: %.2f bpm\n", breathing_rate_bpm);
    printf("Estimated Heart Rate: %.2f bpm\n", heart_rate_bpm);
    
    ifx_fft_destroy(bp_inst);
    ifx_fft_destroy(heart_inst);
    free(bp_fft);
    free(heart_fft);
    free(bp_in);
    free(heart_in);
    processNum++;*/
}

void process_frame(ifx_Cube_R_t* frame, double max_range, ifx_Vector_C_t** vectorRangeArray, ifx_Vector_C_t** vectorPhaseArray, ifx_FFT_t* PhaseFFT, ifx_FFT_t* RangeFFT, ifx_Filter_R_t* br_filt, ifx_Filter_R_t* hr_filt,
    ifx_Vector_R_t* filterOutputHr ,ifx_Vector_R_t* filterOutputBr) {    /*
    //ifx_Complex_t range_fft_arr[(int)SAMPLES_PER_CHIRP];
    //ifx_Complex_t* range_fft = range_fft_arr;
    ifx_Vector_R_t* = malloc(num_chirps_per_Frame * sizeof(ifx_Vector_C_t))
	ifx_Vecctor_C_t** fft_out;*/
    static phase_index;
    calc_range_fft(Range_FFT, frame, vectorRangeArray);
    ifx_Float_t max_val;
    uint32_t range_bin;
    for(int i = 0; i < num_chirps_per_frame; i++);
        if (Range_FFT != NULL) {
            //find max val and max val index
            max_val = ifx_vec_maxabs_r(vectorRangeArray[i])
            range_bin = ifx_vec_max_idx_r(vectorRangeArray[i])

            printf("rangeBin: %d", range_bin); 
            //printf("\nstartIndex:%d, endindex:%d\n", start_index_range, stop_index_range);       
        
            ifx_Float_t wrapped_phase = atan2(IFX_COMPLEX_IMAG(vectorRangeArray[i][range_bin]), IFX_COMPLEX_REAL(vectorRangeArray[i][range_bin]));
            printf("imag:%f , real: %f \n",IFX_COMPLEX_IMAG(vectorRangeArray[i][range_bin]), IFX_COMPLEX_REAL(vectorRangeArray[i][range_bin]));
            if (phase_index < PHASE_BUFFER_SIZE) {
                phase_buffer[phase_index++] = wrapped_phase;
            }
            if (phase_index >= PHASE_BUFFER_SIZE) { 
                //printf("wheres my segfault VONE MILLION-------------------\n");
                process_vital_signs(phase_buffer, PhaseFFT, PHASE_BUFFER_SIZE,br_filt, hr_filt);
                phase_index = 0;
            }
            //free(range_fft);//Seg fauling Not dynamically allocated, doesnt need to be freed.
        }
    
}
